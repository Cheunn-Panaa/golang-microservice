package main

import (
	_ "cheunn-panaa/golang-microservice/api/docs" // docs is generated by Swag CLI, you have to import it.
	"cheunn-panaa/golang-microservice/config"
	"cheunn-panaa/golang-microservice/pkg/api"
	"cheunn-panaa/golang-microservice/pkg/logger"
	"context"
	"os"
	"os/signal"
	"sync/atomic"
	"syscall"
	"time"

	"go.uber.org/zap"
)

func main() {
	cfg := config.AppConfig()

	// configure logging
	logger, _ := logger.New(cfg.Logger.Level)
	defer logger.Sync()
	stdLog := zap.RedirectStdLog(logger)
	defer stdLog()
	logger.Sugar().Infof("Zob")
	server, _ := api.NewServer(cfg, logger)
	httpServer, healthy, ready := server.ListenAndServe()

	// Server run context
	ctx := context.Background()

	// Listen for syscall signals for process to interrupt/quit
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, os.Interrupt, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)
	go func() {
		<-sig

		// all calls to /healthz and /readyz will fail from now on
		atomic.StoreInt32(healthy, 0)
		atomic.StoreInt32(ready, 0)
		// Shutdown signal with grace period of 5 seconds
		shutdownCtx, _ := context.WithTimeout(ctx, 5*time.Second)

		go func() {
			// determine if the http server was started
			if httpServer != nil {
				logger.Debug("Shutting down httpServer ...")
				if err := httpServer.Shutdown(ctx); err != nil {
					logger.Warn("HTTP server graceful shutdown failed", zap.Error(err))
				}
			}
			<-shutdownCtx.Done()

			if shutdownCtx.Err() == context.DeadlineExceeded {
				logger.Fatal("Graceful shutdown timed out.. forcing exit.")
			}
		}()

	}()

	// Wait for server context to be stopped
	<-ctx.Done()
}
